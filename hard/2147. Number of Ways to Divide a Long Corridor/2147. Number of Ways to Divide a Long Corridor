Problem
	3606.	Coupon Code Validator
Solved
Easy

Topics
premium lock icon
Companies

Hint
You are given three arrays of length n that describe the properties of n coupons: code, businessLine, and isActive. The ith coupon has:

code[i]: a string representing the coupon identifier.
businessLine[i]: a string denoting the business category of the coupon.
isActive[i]: a boolean indicating whether the coupon is currently active.
A coupon is considered valid if all of the following conditions hold:

code[i] is non-empty and consists only of alphanumeric characters (a-z, A-Z, 0-9) and underscores (_).
businessLine[i] is one of the following four categories: “electronics”, “grocery”, “pharmacy”, “restaurant”.
isActive[i] is true.
Return an array of the codes of all valid coupons, sorted first by their businessLine in the order: “electronics”, “grocery”, “pharmacy”, “restaurant”, and then by code in lexicographical (ascending) order within each category.

Example 1:

Input: code = [“SAVE20”,””,“PHARMA5”,“SAVE@20”], businessLine = [“restaurant”,“grocery”,“pharmacy”,“restaurant”], isActive = [true,true,true,true]

Output: [“PHARMA5”,“SAVE20”]

Explanation:

First coupon is valid.
Second coupon has empty code (invalid).
Third coupon is valid.
Fourth coupon has special character @ (invalid).
Example 2:

Input: code = [“GROCERY15”,“ELECTRONICS_50”,“DISCOUNT10”], businessLine = [“grocery”,“electronics”,“invalid”], isActive = [false,true,true]

Output: [“ELECTRONICS_50”]

Explanation:

First coupon is inactive (invalid).
Second coupon is valid.
Third coupon has invalid business line (invalid).

Constraints:

n == code.length == businessLine.length == isActive.length
1 <= n <= 100
0 <= code[i].length, businessLine[i].length <= 100
code[i] and businessLine[i] consist of printable ASCII characters.
isActive[i] is either true or false.

Approach
	1.	Define the required business line priority using a dictionary that maps each valid category to its sort rank.
	2.	Precompile a regular expression that matches valid coupon codes (only letters, digits, and underscores, and at least one character).
	3.	Iterate through the three arrays in parallel using zip.
	4.	For each coupon, apply the validity checks in order:
	•	Skip if the coupon is not active.
	•	Skip if businessLine is not one of the allowed categories.
	•	Skip if the code is empty or fails the regex validation.
	5.	For each valid coupon, store a tuple (businessLine_rank, code) in a list.
	6.	Sort the list of tuples. Tuple sorting ensures:
	•	Primary order by business line rank.
	•	Secondary order by code lexicographically.
	7.	Extract and return only the coupon codes from the sorted tuples.

Why This Solution
	•	A dictionary order provides an explicit, constant-time way to validate business lines and enforce the required custom category order during sorting.
	•	A precompiled regex cleanly enforces the “alphanumeric or underscore only” constraint and keeps validation logic simple and reliable.
	•	Collecting (rank, code) tuples aligns directly with the output sorting rules and lets Python’s default tuple sort handle both ordering levels without custom comparator logic.
	•	Early continue checks reduce nesting and make the validation flow easy to follow.

Complexity
	•	Time Complexity: O(n log n), due to sorting the valid coupons (with n up to 100).
	•	Space Complexity: O(n), for storing the list of valid coupons.

Solution

from typing import List
import re

class Solution:
    def validateCoupons(self, code: List[str], businessLine: List[str], isActive: List[bool]) -> List[str]:
        order = {"electronics": 0, "grocery": 1, "pharmacy": 2, "restaurant": 3}
        valid_code = re.compile(r"^[A-Za-z0-9_]+$")

        good = []
        for c, b, active in zip(code, businessLine, isActive):
            if not active:
                continue
            if b not in order:
                continue
            if not c or not valid_code.match(c):
                continue
            good.append((order[b], c))

        good.sort()
        return [c for _, c in good]